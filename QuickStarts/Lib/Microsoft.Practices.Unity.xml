<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Practices.Unity</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Practices.Unity.DependencyResolutionAttribute">
            <summary>
            Base class for attributes that can be placed on parameters
            or properties to specify how to resolve the value for
            that parameter or property.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.DependencyResolutionAttribute.CreateResolver(System.Type)">
            <summary>
            Create an instance of <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/> that
            will be used to get the value for the member this attribute is
            applied to.
            </summary>
            <param name="typeToResolve">Type of parameter or property that
            this attribute is decoration.</param>
            <returns>The resolver object.</returns>
        </member>
        <member name="T:Microsoft.Practices.Unity.InjectionConstructorAttribute">
            <summary>
            This attribute is used to indicate which constructor to choose when
            the container attempts to build a type.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.InjectionMethodAttribute">
            <summary>
            This attribute is used to mark methods that should be called when
            the container is building an object.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.DependencyAttribute">
            <summary>
            This attribute is used to mark properties and parameters as targets for injection.
            </summary>
            <remarks>
            For properties, this attribute is necessary for injection to happen. For parameters,
            it's not needed unless you want to specify additional information to control how
            the parameter is resolved.
            </remarks>
        </member>
        <member name="M:Microsoft.Practices.Unity.DependencyAttribute.#ctor">
            <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.DependencyAttribute"/> with no name.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.DependencyAttribute.#ctor(System.String)">
            <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.DependencyAttribute"/> with the given name.
            </summary>
            <param name="name">Name to use when resolving this dependency.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.DependencyAttribute.CreateResolver(System.Type)">
            <summary>
            Create an instance of <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/> that
            will be used to get the value for the member this attribute is
            applied to.
            </summary>
            <param name="typeToResolve">Type of parameter or property that
            this attribute is decoration.</param>
            <returns>The resolver object.</returns>
        </member>
        <member name="P:Microsoft.Practices.Unity.DependencyAttribute.Name">
            <summary>
            The name specified in the constructor.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.ExtensionContext">
            <summary>
            The <see cref="T:Microsoft.Practices.Unity.ExtensionContext"/> class provides the means for extension objects
            to manipulate the internal state of the <see cref="T:Microsoft.Practices.Unity.UnityContainer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.ExtensionContext.RegisterNamedType(System.Type,System.String)">
            <summary>
            Store a type/name pair for later resolution.
            </summary>
            <remarks>
            <para>
            When users register type mappings (or other things) with a named key, this method
            allows you to register that name with the container so that when the <see cref="M:Microsoft.Practices.Unity.IUnityContainer.ResolveAll``1"/>
            method is called, that name is included in the list that is returned.
            </para></remarks>
            <param name="t"><see cref="T:System.Type"/> to register.</param>
            <param name="name">Name assocated with that type.</param>
        </member>
        <member name="P:Microsoft.Practices.Unity.ExtensionContext.Container">
            <summary>
            The container that this context is associated with.
            </summary>
            <value>The <see cref="T:Microsoft.Practices.Unity.IUnityContainer"/> object.</value>
        </member>
        <member name="P:Microsoft.Practices.Unity.ExtensionContext.Strategies">
            <summary>
            The strategies this container uses.
            </summary>
            <value>The <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1"/> that the container uses to build objects.</value>
        </member>
        <member name="P:Microsoft.Practices.Unity.ExtensionContext.BuildPlanStrategies">
            <summary>
            The strategies this container uses to construct build plans.
            </summary>
            <value>The <see cref="T:Microsoft.Practices.ObjectBuilder2.StagedStrategyChain`1"/> that this container uses when creating
            build plans.</value>
        </member>
        <member name="P:Microsoft.Practices.Unity.ExtensionContext.Policies">
            <summary>
            The policies this container uses.
            </summary>
            <remarks>The <see cref="T:Microsoft.Practices.ObjectBuilder2.IPolicyList"/> the that container uses to build objects.</remarks>
        </member>
        <member name="P:Microsoft.Practices.Unity.ExtensionContext.Locator">
            <summary>
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.IReadWriteLocator"/> that this container uses.
            </summary>
            <value>The Locator is an object that is used to store information to be found later during the build process.</value>
        </member>
        <member name="P:Microsoft.Practices.Unity.ExtensionContext.Lifetime">
            <summary>
            The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer"/> that this container uses.
            </summary>
            <value>The <see cref="T:Microsoft.Practices.ObjectBuilder2.ILifetimeContainer"/> is used to manage <see cref="T:System.IDisposable"/> objects that the container is managing.</value>
        </member>
        <member name="E:Microsoft.Practices.Unity.ExtensionContext.Registering">
            <summary>
            This event is raised when the <see cref="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager)"/> method,
            or one of its overloads, is called.
            </summary>
        </member>
        <member name="E:Microsoft.Practices.Unity.ExtensionContext.RegisteringInstance">
            <summary>
            This event is raised when the <see cref="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.String,System.Object,Microsoft.Practices.Unity.LifetimeManager)"/> method,
            or one of its overloads, is called.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.IUnityContainerExtensionConfigurator">
            <summary>
            Base interface for all extension configuration interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.IUnityContainerExtensionConfigurator.Container">
            <summary>
            Retrieve the container instance that we are currently configuring.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.NamedEventArgs">
            <summary>
            An EventArgs class that holds a string Name.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.NamedEventArgs.#ctor">
            <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.NamedEventArgs"/> with a null name.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.NamedEventArgs.#ctor(System.String)">
            <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.NamedEventArgs"/> with the given name.
            </summary>
            <param name="name">Name to store.</param>
        </member>
        <member name="P:Microsoft.Practices.Unity.NamedEventArgs.Name">
            <summary>
            The name.
            </summary>
            <value>Name used for this event arg object.</value>
        </member>
        <member name="T:Microsoft.Practices.Unity.RegisterEventArgs">
            <summary>
            Event argument class for the <see cref="E:Microsoft.Practices.Unity.ExtensionContext.Registering"/> event.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.RegisterEventArgs.#ctor(System.Type,System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            Create a new instance of <see cref="T:Microsoft.Practices.Unity.RegisterEventArgs"/>.
            </summary>
            <param name="typeFrom">Type to map from.</param>
            <param name="typeTo">Type to map to.</param>
            <param name="name">Name for the registration.</param>
            <param name="lifetimeManager"><see cref="P:Microsoft.Practices.Unity.RegisterEventArgs.LifetimeManager"/> to manage instances.</param>
        </member>
        <member name="P:Microsoft.Practices.Unity.RegisterEventArgs.TypeFrom">
            <summary>
            Type to map from.
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.RegisterEventArgs.TypeTo">
            <summary>
            Type to map to.
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.RegisterEventArgs.LifetimeManager">
            <summary>
            <see cref="P:Microsoft.Practices.Unity.RegisterEventArgs.LifetimeManager"/> to manage instances.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.RegisterInstanceEventArgs">
            <summary>
            Event argument class for the <see cref="E:Microsoft.Practices.Unity.ExtensionContext.RegisteringInstance"/> event.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.RegisterInstanceEventArgs.#ctor">
            <summary>
            Create a default <see cref="T:Microsoft.Practices.Unity.RegisterInstanceEventArgs"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.RegisterInstanceEventArgs.#ctor(System.Type,System.Object,System.String,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            Create a <see cref="T:Microsoft.Practices.Unity.RegisterInstanceEventArgs"/> instance initialized with the given arguments.
            </summary>
            <param name="registeredType">Type of instance being registered.</param>
            <param name="instance">The instance object itself.</param>
            <param name="name">Name to register under, null if default registration.</param>
            <param name="lifetimeManager"><see cref="P:Microsoft.Practices.Unity.RegisterInstanceEventArgs.LifetimeManager"/> object that handles how
            the instance will be owned.</param>
        </member>
        <member name="P:Microsoft.Practices.Unity.RegisterInstanceEventArgs.RegisteredType">
            <summary>
            Type of instance being registered.
            </summary>
            <value>
            Type of instance being registered.
            </value>
        </member>
        <member name="P:Microsoft.Practices.Unity.RegisterInstanceEventArgs.Instance">
            <summary>
            Instance object being registered.
            </summary>
            <value>Instance object being registered</value>
        </member>
        <member name="P:Microsoft.Practices.Unity.RegisterInstanceEventArgs.LifetimeManager">
            <summary>
            <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls ownership of
            this instance.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.UnityContainerExtension">
            <summary>
            Base class for all <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> extension objects.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerExtension.InitializeExtension(Microsoft.Practices.Unity.ExtensionContext)">
            <summary>
            The container calls this method when the extension is added.
            </summary>
            <param name="context">A <see cref="T:Microsoft.Practices.Unity.ExtensionContext"/> instance that gives the
            extension access to the internals of the container.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerExtension.Initialize">
            <summary>
            Initial the container with this extension's functionality.
            </summary>
            <remarks>
            When overridden in a derived class, this method will modify the given
            <see cref="T:Microsoft.Practices.Unity.ExtensionContext"/> by adding strategies, policies, etc. to
            install it's functions into the container.</remarks>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerExtension.Remove">
            <summary>
            Removes the extension's functions from the container.
            </summary>
            <remarks>
            <para>
            This method is called when extensions are being removed from the container. It can be
            used to do things like disconnect event handlers or clean up member state. You do not
            need to remove strategies or policies here; the container will do that automatically.
            </para>
            <para>
            The default implementation of this method does nothing.</para>
            </remarks>
        </member>
        <member name="P:Microsoft.Practices.Unity.UnityContainerExtension.Container">
            <summary>
            The container this extension has been added to.
            </summary>
            <value>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> that this extension has been added to.</value>
        </member>
        <member name="P:Microsoft.Practices.Unity.UnityContainerExtension.Context">
            <summary>
            The <see cref="T:Microsoft.Practices.Unity.ExtensionContext"/> object used to manipulate
            the inner state of the container.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.InjectedMembers">
            <summary>
            A Unity container extension that allows you to configure
            which constructors, properties, and methods get injected
            via an API rather than through attributes.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectedMembers.Initialize">
            <summary>
            Initial the container with this extension's functionality.
            </summary>
            <remarks>
            When overridden in a derived class, this method will modify the given
            <see cref="T:Microsoft.Practices.Unity.ExtensionContext"/> by adding strategies, policies, etc. to
            install it's functions into the container.</remarks>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectedMembers.ConfigureInjectionFor``1(Microsoft.Practices.Unity.InjectionMember[])">
            <summary>
            API to configure the injection settings for a particular type.
            </summary>
            <typeparam name="TTypeToInject">Type the injection is being configured for.</typeparam>
            <param name="injectionMembers">Objects containing the details on which members to inject and how.</param>
            <returns>This extension object.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectedMembers.ConfigureInjectionFor``1(System.String,Microsoft.Practices.Unity.InjectionMember[])">
            <summary>
            API to configure the injection settings for a particular type/name pair.
            </summary>
            <typeparam name="TTypeToInject">Type the injection is being configured for.</typeparam>
            <param name="name">Name of registration</param>
            <param name="injectionMembers">Objects containing the details on which members to inject and how.</param>
            <returns>This extension object.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectedMembers.ConfigureInjectionFor(System.Type,Microsoft.Practices.Unity.InjectionMember[])">
            <summary>
            API to configure the injection settings for a particular type.
            </summary>
            <param name="typeToInject">Type to configure.</param>
            <param name="injectionMembers">Objects containing the details on which members to inject and how.</param>
            <returns>This extension object.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectedMembers.ConfigureInjectionFor(System.Type,System.String,Microsoft.Practices.Unity.InjectionMember[])">
            <summary>
            API to configure the injection settings for a particular type/name pair.
            </summary>
            <param name="typeToInject">Type to configure.</param>
            <param name="name">Name of registration.</param>
            <param name="injectionMembers">Objects containing the details on which members to inject and how.</param>
            <returns>This extension object.</returns>
        </member>
        <member name="T:Microsoft.Practices.Unity.InjectionConstructor">
            <summary>
            A class that holds the collection of information
            for a constructor, so that the container can
            be configured to call this constructor.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.InjectionMember">
            <summary>
            Base class for objects that can be used to configure what
            class members get injected by the container.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionMember.AddPolicies(System.Type,Microsoft.Practices.ObjectBuilder2.IPolicyList)">
            <summary>
            Add policies to the <paramref name="policies"/> to configure the
            container to call this constructor with the appropriate parameter values.
            </summary>
            <param name="typeToCreate">Type to register.</param>
            <param name="policies">Policy list to add policies to.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionMember.AddPolicies(System.Type,System.String,Microsoft.Practices.ObjectBuilder2.IPolicyList)">
            <summary>
            Add policies to the <paramref name="policies"/> to configure the
            container to call this constructor with the appropriate parameter values.
            </summary>
            <param name="typeToCreate">Type to register.</param>
            <param name="name">Name used to resolve the type object.</param>
            <param name="policies">Policy list to add policies to.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionConstructor.#ctor(System.Object[])">
            <summary>
            Create a new instance of <see cref="T:Microsoft.Practices.Unity.InjectionConstructor"/> that looks
            for a constructor with the given set of parameters.
            </summary>
            <param name="parameterValues">The values for the parameters, that will
            be converted to <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue"/> objects.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionConstructor.AddPolicies(System.Type,System.String,Microsoft.Practices.ObjectBuilder2.IPolicyList)">
            <summary>
            Add policies to the <paramref name="policies"/> to configure the
            container to call this constructor with the appropriate parameter values.
            </summary>
            <param name="typeToCreate">Type to register.</param>
            <param name="name">Name used to resolve the type object.</param>
            <param name="policies">Policy list to add policies to.</param>
        </member>
        <member name="T:Microsoft.Practices.Unity.InjectionMethod">
            <summary>
            An <see cref="T:Microsoft.Practices.Unity.InjectionMember"/> that configures the
            container to call a method as part of buildup.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionMethod.#ctor(System.String,System.Object[])">
            <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.InjectionMethod"/> instance which will configure
            the container to call the given methods with the given parameters.
            </summary>
            <param name="methodName">Name of the method to call.</param>
            <param name="methodParameters">Parameter values for the method.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionMethod.AddPolicies(System.Type,System.String,Microsoft.Practices.ObjectBuilder2.IPolicyList)">
            <summary>
            Add policies to the <paramref name="policies"/> to configure the
            container to call this constructor with the appropriate parameter values.
            </summary>
            <param name="typeToCreate">Type to register.</param>
            <param name="name">Name used to resolve the type object.</param>
            <param name="policies">Policy list to add policies to.</param>
        </member>
        <member name="T:Microsoft.Practices.Unity.InjectionParameter">
            <summary>
            A class that holds on to the given value and provides
            the required <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/>
            when the container is configured.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.InjectionParameterValue">
            <summary>
            Base type for objects that are used to configure parameters for
            constructor or method injection, or for getting the value to
            be injected into a property.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionParameterValue.GetResolverPolicy">
            <summary>
            Return a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/> instance that will
            return this types value for the parameter.
            </summary>
            <returns>The <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/>.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionParameterValue.ToParameters(System.Object[])">
            <summary>
            Convert the given set of arbitrary values to a sequence of InjectionParameterValue
            objects. The rules are: If it's already an InjectionParameterValue, return it. If
            it's a Type, return a ResolvedParameter object for that type. Otherwise return
            an InjectionParameter object for that value.
            </summary>
            <param name="values">The values to build the sequence from.</param>
            <returns>The resulting converted sequence.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionParameterValue.ToParameter(System.Object)">
            <summary>
            Convert an arbitrary value to an InjectionParameterValue object. The rules are: 
            If it's already an InjectionParameterValue, return it. If it's a Type, return a
            ResolvedParameter object for that type. Otherwise return an InjectionParameter
            object for that value.
            </summary>
            <param name="value">The value to convert.</param>
            <returns>The resulting <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue"/>.</returns>
        </member>
        <member name="P:Microsoft.Practices.Unity.InjectionParameterValue.ParameterType">
            <summary>
            The type of parameter this object represents.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionParameter.#ctor(System.Object)">
            <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.InjectionParameter"/> that stores
            the given value, using the runtime type of that value as the
            type of the parameter.
            </summary>
            <param name="parameterValue">Value to be injected for this parameter.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionParameter.#ctor(System.Type,System.Object)">
            <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.InjectionParameter"/> that stores
            the given value, associated with the given type.
            </summary>
            <param name="parameterType">Type of the parameter.</param>
            <param name="parameterValue">Value of the parameter</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionParameter.GetResolverPolicy">
            <summary>
            Return a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/> instance that will
            return this types value for the parameter.
            </summary>
            <returns>The <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/>.</returns>
        </member>
        <member name="P:Microsoft.Practices.Unity.InjectionParameter.ParameterType">
            <summary>
            The type of parameter this object represents.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.InjectionParameter`1">
            <summary>
            A generic version of <see cref="T:Microsoft.Practices.Unity.InjectionParameter"/> that makes it a
            little easier to specify the type of the parameter.
            </summary>
            <typeparam name="TParameter">Type of parameter.</typeparam>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionParameter`1.#ctor(`0)">
            <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.InjectionParameter`1"/>.
            </summary>
            <param name="parameterValue">Value for the parameter.</param>
        </member>
        <member name="T:Microsoft.Practices.Unity.InjectionProperty">
            <summary>
            This class stores information about which properties to inject,
            and will configure the container accordingly.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionProperty.#ctor(System.String)">
            <summary>
            Configure the container to inject the given property name,
            resolving the value via the container.
            </summary>
            <param name="propertyName">Name of the property to inject.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionProperty.#ctor(System.String,System.Object)">
            <summary>
            Configure the container to inject the given property name,
            using the value supplied. This value is converted to an
            <see cref="T:Microsoft.Practices.Unity.InjectionParameterValue"/> object using the
            rules defined by the <see cref="M:Microsoft.Practices.Unity.InjectionParameterValue.ToParameters(System.Object[])"/>
            method.
            </summary>
            <param name="propertyName">Name of property to inject.</param>
            <param name="propertyValue">Value for property.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.InjectionProperty.AddPolicies(System.Type,System.String,Microsoft.Practices.ObjectBuilder2.IPolicyList)">
            <summary>
            Add policies to the <paramref name="policies"/> to configure the
            container to call this constructor with the appropriate parameter values.
            </summary>
            <param name="typeToCreate">Type to register.</param>
            <param name="name">Name used to resolve the type object.</param>
            <param name="policies">Policy list to add policies to.</param>
        </member>
        <member name="T:Microsoft.Practices.Unity.IUnityContainer">
            <summary>
            Interface defining the behavior of the Unity dependency injection container.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``2">
            <summary>
            RegisterType a type mapping with the container.
            </summary>
            <remarks>
            <para>
            This method is used to tell the container that when asked for type <typeparamref name="TFrom"/>,
            actually return an instance of type <typeparamref name="TTo"/>. This is very useful for
            getting instances of interfaces.
            </para>
            <para>
            This overload registers a default mapping and transient lifetime.
            </para>
            </remarks>
            <typeparam name="TFrom"><see cref="T:System.Type"/> that will be requested.</typeparam>
            <typeparam name="TTo"><see cref="T:System.Type"/> that will actually be returned.</typeparam>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``2(Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/>.
            </summary>
            <typeparam name="TFrom"><see cref="T:System.Type"/> that will be requested.</typeparam>
            <typeparam name="TTo"><see cref="T:System.Type"/> that will actually be returned.</typeparam>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``2(System.String)">
            <summary>
            RegisterType a type mapping with the container.
            </summary>
            <remarks>
            This method is used to tell the container that when asked for type <typeparamref name="TFrom"/>,
            actually return an instance of type <typeparamref name="TTo"/>. This is very useful for
            getting instances of interfaces.
            </remarks>
            <typeparam name="TFrom"><see cref="T:System.Type"/> that will be requested.</typeparam>
            <typeparam name="TTo"><see cref="T:System.Type"/> that will actually be returned.</typeparam>
            <param name="name">Name of this mapping.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``2(System.String,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/>.
            </summary>
            <typeparam name="TFrom"><see cref="T:System.Type"/> that will be requested.</typeparam>
            <typeparam name="TTo"><see cref="T:System.Type"/> that will actually be returned.</typeparam>
            <param name="name">Name to use for registration, null if a default registration.</param>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``1(Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> for the given type with the container.
            No type mapping is performed for this type.
            </summary>
            <typeparam name="T">The type to apply the <paramref name="lifetimeManager"/> to.</typeparam>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType``1(System.String,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
            <typeparam name="T">The type to apply the <paramref name="lifetimeManager"/> to.</typeparam>
            <param name="name">Name that will be used to request the type.</param>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,System.Type)">
            <summary>
            RegisterType a type mapping with the container.
            </summary>
            <remarks>
            <para>
            This method is used to tell the container that when asked for type <paramref name="from"/>,
            actually return an instance of type <paramref name="to"/>. This is very useful for
            getting instances of interfaces.
            </para>
            <para>
            This overload registers a default mapping.
            </para>
            </remarks>
            <param name="from"><see cref="T:System.Type"/> that will be requested.</param>
            <param name="to"><see cref="T:System.Type"/> that will actually be returned.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,System.Type,System.String)">
            <summary>
            RegisterType a type mapping with the container.
            </summary>
            <remarks>
            This method is used to tell the container that when asked for type <paramref name="from"/>,
            actually return an instance of type <paramref name="to"/>. This is very useful for
            getting instances of interfaces.
            </remarks>
            <param name="from"><see cref="T:System.Type"/> that will be requested.</param>
            <param name="to"><see cref="T:System.Type"/> that will actually be returned.</param>
            <param name="name">Name to use for registration, null if a default registration.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,System.Type,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/>.
            </summary>
            <param name="from"><see cref="T:System.Type"/> that will be requested.</param>
            <param name="to"><see cref="T:System.Type"/> that will actually be returned.</param>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
            <param name="t">The <see cref="T:System.Type"/> to apply the <paramref name="lifetimeManager"/> to.</param>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
            <param name="t">The <see cref="T:System.Type"/> to apply the <paramref name="lifetimeManager"/> to.</param>
            <param name="name">Name to use for registration, null if a default registration.</param>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterType(System.Type,System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/>.
            </summary>
            <param name="from"><see cref="T:System.Type"/> that will be requested.</param>
            <param name="to"><see cref="T:System.Type"/> that will actually be returned.</param>
            <param name="name">Name to use for registration, null if a default registration.</param>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance``1(``0)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            <para>
            This overload does a default registration and has the container take over the lifetime of the instance.</para>
            </remarks>
            <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
            <param name="instance">Object to returned.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance``1(``0,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            <para>
            This overload does a default registration (name = null).
            </para>
            </remarks>
            <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
            <param name="instance">Object to returned.</param>
            <param name="lifetimeManager">
            <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> object that controls how this instance will be managed by the container.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance``1(System.String,``0)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            <para>
            This overload automatically has the container take ownership of the <paramref name="instance"/>.</para>
            </remarks>
            <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
            <param name="instance">Object to returned.</param>
            <param name="name">Name for registration.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance``1(System.String,``0,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            </remarks>
            <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
            <param name="instance">Object to returned.</param>
            <param name="name">Name for registration.</param>
            <param name="lifetimeManager">
            <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> object that controls how this instance will be managed by the container.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.Object)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            <para>
            This overload does a default registration and has the container take over the lifetime of the instance.</para>
            </remarks>
            <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
            <param name="instance">Object to returned.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.Object,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            <para>
            This overload does a default registration (name = null).
            </para>
            </remarks>
            <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
            <param name="instance">Object to returned.</param>
            <param name="lifetimeManager">
            <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> object that controls how this instance will be managed by the container.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.String,System.Object)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            <para>
            This overload automatically has the container take ownership of the <paramref name="instance"/>.</para>
            </remarks>
            <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
            <param name="instance">Object to returned.</param>
            <param name="name">Name for registration.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RegisterInstance(System.Type,System.String,System.Object,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            </remarks>
            <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
            <param name="instance">Object to returned.</param>
            <param name="name">Name for registration.</param>
            <param name="lifetime">
            <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> object that controls how this instance will be managed by the container.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.Resolve``1">
            <summary>
            Resolve an instance of the default requested type from the container.
            </summary>
            <typeparam name="T"><see cref="T:System.Type"/> of object to get from the container.</typeparam>
            <returns>The retrieved object.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.Resolve``1(System.String)">
            <summary>
            Resolve an instance of the requested type with the given name from the container.
            </summary>
            <typeparam name="T"><see cref="T:System.Type"/> of object to get from the container.</typeparam>
            <param name="name">Name of the object to retrieve.</param>
            <returns>The retrieved object.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.Resolve(System.Type)">
            <summary>
            Resolve an instance of the default requested type from the container.
            </summary>
            <param name="t"><see cref="T:System.Type"/> of object to get from the container.</param>
            <returns>The retrieved object.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.Resolve(System.Type,System.String)">
            <summary>
            Resolve an instance of the requested type with the given name from the container.
            </summary>
            <param name="t"><see cref="T:System.Type"/> of object to get from the container.</param>
            <param name="name">Name of the object to retrieve.</param>
            <returns>The retrieved object.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.ResolveAll``1">
            <summary>
            Return instances of all registered types requested.
            </summary>
            <remarks>
            <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type"/> but different names.
            </para>
            <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
            </remarks>
            <typeparam name="T">The type requested.</typeparam>
            <returns>Set of objects of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.ResolveAll(System.Type)">
            <summary>
            Return instances of all registered types requested.
            </summary>
            <remarks>
            <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type"/> but different names.
            </para>
            <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
            </remarks>
            <param name="t">The type requested.</param>
            <returns>Set of objects of type <paramref name="t"/>.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.BuildUp``1(``0)">
            <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
            <remarks>
            <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
            <para>
            This overload uses the default registrations.
            </para>
            </remarks>
            <typeparam name="T"><see cref="T:System.Type"/> of object to perform injection on.</typeparam>
            <param name="existing">Instance to build up.</param>
            <returns>The resulting object. By default, this will be <paramref name="existing"/>, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <typeparamref name="T"/>).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.BuildUp``1(``0,System.String)">
            <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
            <remarks>
            <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para></remarks>
            <typeparam name="T"><see cref="T:System.Type"/> of object to perform injection on.</typeparam>
            <param name="existing">Instance to build up.</param>
            <param name="name">name to use when looking up the typemappings and other configurations.</param>
            <returns>The resulting object. By default, this will be <paramref name="existing"/>, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <typeparamref name="T"/>).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.BuildUp(System.Type,System.Object)">
            <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
            <remarks>
            <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
            <para>
            This overload uses the default registrations.
            </para>
            </remarks>
            <param name="t"><see cref="T:System.Type"/> of object to perform injection on.</param>
            <param name="existing">Instance to build up.</param>
            <returns>The resulting object. By default, this will be <paramref name="existing"/>, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t"/>).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.BuildUp(System.Type,System.Object,System.String)">
            <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
            <remarks>
            <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para></remarks>
            <param name="t"><see cref="T:System.Type"/> of object to perform injection on.</param>
            <param name="existing">Instance to build up.</param>
            <param name="name">name to use when looking up the typemappings and other configurations.</param>
            <returns>The resulting object. By default, this will be <paramref name="existing"/>, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t"/>).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.Teardown(System.Object)">
            <summary>
            Run an existing object through the container, and clean it up.
            </summary>
            <param name="o">The object to tear down.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.AddExtension(Microsoft.Practices.Unity.UnityContainerExtension)">
            <summary>
            Add an extension object to the container.
            </summary>
            <param name="extension"><see cref="T:Microsoft.Practices.Unity.UnityContainerExtension"/> to add.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.AddNewExtension``1">
            <summary>
            Creates a new extension object and adds it to the container.
            </summary>
            <typeparam name="TExtension">Type of <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension"/> to add. The extension type
            must have a zero-argument public constructor.</typeparam>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.Configure``1">
            <summary>
            Resolve access to a configuration interface exposed by an extension.
            </summary>
            <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
            <typeparam name="TConfigurator">The configuration interface required.</typeparam>
            <returns>The requested extension's configuration interface, or null if not found.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.Configure(System.Type)">
            <summary>
            Resolve access to a configuration interface exposed by an extension.
            </summary>
            <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
            <param name="configurationInterface"><see cref="T:System.Type"/> of configuration interface required.</param>
            <returns>The requested extension's configuration interface, or null if not found.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.RemoveAllExtensions">
            <summary>
            Remove all installed extensions from this container.
            </summary>
            <remarks>
            <para>
            This method removes all extensions from the container, including the default ones
            that implement the out-of-the-box behavior. After this method, if you want to use
            the container again you will need to either readd the default extensions or replace
            them with your own.
            </para>
            <para>
            The registered instances and singletons that have already been set up in this container
            do not get removed.
            </para>
            </remarks>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.IUnityContainer.CreateChildContainer">
            <summary>
            Create a child container.
            </summary>
            <remarks>
            A child container shares the parent's configuration, but can be configured with different
            settings or lifetime.</remarks>
            <returns>The new child container.</returns>
        </member>
        <member name="P:Microsoft.Practices.Unity.IUnityContainer.Parent">
            <summary>
            The parent of this container.
            </summary>
            <value>The parent container, or null if this container doesn't have one.</value>
        </member>
        <member name="T:Microsoft.Practices.Unity.ContainerControlledLifetimeManager">
            <summary>
            A <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that holds onto the instance given to it.
            When the <see cref="T:Microsoft.Practices.Unity.ContainerControlledLifetimeManager"/> is disposed,
            the instance is disposed with it.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.LifetimeManager">
            <summary>
            Base class for Lifetime managers - classes that control how
            and when instances are created by the Unity container.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.LifetimeManager.GetValue">
            <summary>
            Retrieve a value from the backing store associated with this Lifetime policy.
            </summary>
            <returns>the object desired, or null if no such object is currently stored.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.LifetimeManager.SetValue(System.Object)">
            <summary>
            Stores the given value into backing store for retrieval later.
            </summary>
            <param name="newValue">The object being stored.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.LifetimeManager.RemoveValue">
            <summary>
            Remove the given object from backing store.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.ContainerControlledLifetimeManager.GetValue">
            <summary>
            Retrieve a value from the backing store associated with this Lifetime policy.
            </summary>
            <returns>the object desired, or null if no such object is currently stored.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.ContainerControlledLifetimeManager.SetValue(System.Object)">
            <summary>
            Stores the given value into backing store for retrieval later.
            </summary>
            <param name="newValue">The object being stored.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.ContainerControlledLifetimeManager.RemoveValue">
            <summary>
            Remove the given object from backing store.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.ContainerControlledLifetimeManager.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Microsoft.Practices.Unity.ContainerControlledLifetimeManager.Dispose(System.Boolean)">
            <summary>
            Standard Dispose pattern implementation. Not needed, but it keeps FxCop happy.
            </summary>
            <param name="disposing">Always true, since we don't have a finalizer.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.ContainerControlledLifetimeManager.Recover">
            <summary>
            A method that does whatever is needed to clean up
            as part of cleaning up after an exception.
            </summary>
            <remarks>
            Don't do anything that could throw in this method,
            it will cause later recover operations to get skipped
            and play real havok with the stack trace.
            </remarks>
        </member>
        <member name="T:Microsoft.Practices.Unity.ExternallyControlledLifetimeManager">
            <summary>
            A <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that holds a weak reference to
            it's managed instance.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.ExternallyControlledLifetimeManager.GetValue">
            <summary>
            Retrieve a value from the backing store associated with this Lifetime policy.
            </summary>
            <returns>the object desired, or null if no such object is currently stored.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.ExternallyControlledLifetimeManager.SetValue(System.Object)">
            <summary>
            Stores the given value into backing store for retrieval later.
            </summary>
            <param name="newValue">The object being stored.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.ExternallyControlledLifetimeManager.RemoveValue">
            <summary>
            Remove the given object from backing store.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.ObjectBuilder.DefaultUnityConstructorSelectorPolicy">
            <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IConstructorSelectorPolicy"/> that is
            aware of the build keys used by the Unity container.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.ObjectBuilder.DefaultUnityConstructorSelectorPolicy.CreateResolver(System.Reflection.ParameterInfo)">
            <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/> instance for the given
            <see cref="T:System.Reflection.ParameterInfo"/>.
            </summary>
            <remarks>
            This implementation looks for the Unity <see cref="T:Microsoft.Practices.Unity.DependencyAttribute"/> on the
            parameter and uses it to create an instance of <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy"/>
            for this parameter.</remarks>
            <param name="param">Parameter to create the resolver for.</param>
            <returns>The resolver object.</returns>
        </member>
        <member name="T:Microsoft.Practices.Unity.ObjectBuilder.DefaultUnityMethodSelectorPolicy">
            <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IMethodSelectorPolicy"/> that is aware
            of the build keys used by the Unity container.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.ObjectBuilder.DefaultUnityMethodSelectorPolicy.CreateResolver(System.Reflection.ParameterInfo)">
            <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/> instance for the given
            <see cref="T:System.Reflection.ParameterInfo"/>.
            </summary>
            <param name="parameter">Parameter to create the resolver for.</param>
            <returns>The resolver object.</returns>
        </member>
        <member name="T:Microsoft.Practices.Unity.ObjectBuilder.DefaultUnityPropertySelectorPolicy">
            <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IPropertySelectorPolicy"/> that is aware of
            the build keys used by the unity container.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.ObjectBuilder.DefaultUnityPropertySelectorPolicy.CreateResolver(System.Reflection.PropertyInfo)">
            <summary>
            Create a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/> for the given
            property.
            </summary>
            <param name="property">Property to create resolver for.</param>
            <returns>The resolver object.</returns>
        </member>
        <member name="T:Microsoft.Practices.Unity.ObjectBuilder.LiteralValueDependencyResolverPolicy">
            <summary>
            A <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/> implementation that returns
            the value set in the constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.ObjectBuilder.LiteralValueDependencyResolverPolicy.#ctor(System.Object)">
            <summary>
            Create a new instance of <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.LiteralValueDependencyResolverPolicy"/>
            which will return the given value when resolved.
            </summary>
            <param name="dependencyValue">The value to return.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.ObjectBuilder.LiteralValueDependencyResolverPolicy.Resolve(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
            <summary>
            Get the value for a dependency.
            </summary>
            <param name="context">Current build context.</param>
            <returns>The value for the dependency.</returns>
        </member>
        <member name="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy">
            <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/> that stores a
            type and name, and at resolution time puts them together into a
            <see cref="T:Microsoft.Practices.ObjectBuilder2.NamedTypeBuildKey"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.#ctor(System.Type,System.String)">
            <summary>
            Create an instance of <see cref="T:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy"/>
            with the given type and name.
            </summary>
            <param name="type">The type.</param>
            <param name="name">The name (may be null).</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
            <summary>
            Resolve the value for a dependency.
            </summary>
            <param name="context">Current build context.</param>
            <returns>The value for the dependency.</returns>
        </member>
        <member name="P:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Type">
            <summary>
            The type that this resolver resolves.
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Name">
            <summary>
            The name that this resolver resolves.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedConstructorSelectorPolicy">
            <summary>
            An implementation of <see cref="T:Microsoft.Practices.ObjectBuilder2.IConstructorSelectorPolicy"/> that selects
            the given constructor and creates the appropriate resolvers to call it with
            the specified parameters.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedMemberSelectorPolicy">
            <summary>
            Helper base class for implementing selector policies that need to
            set up dependency resolver policies.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedMemberSelectorPolicy.AddParameterResolvers(Microsoft.Practices.ObjectBuilder2.IPolicyList,System.Collections.Generic.IEnumerable{Microsoft.Practices.Unity.InjectionParameterValue},Microsoft.Practices.ObjectBuilder2.SelectedMemberWithParameters)">
            <summary>
            Add dependency resolvers to the policy set.
            </summary>
            <param name="policies">PolicyList to add the resolvers to.</param>
            <param name="parameterValues">Objects supplying the dependency resolvers.</param>
            <param name="result">Result object to store the keys in.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedConstructorSelectorPolicy.SelectConstructor(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
            <summary>
            Choose the constructor to call for the given type.
            </summary>
            <param name="context">Current build context</param>
            <returns>The chosen constructor.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedMethodsSelectorPolicy.SelectMethods(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
            <summary>
            Return the sequence of methods to call while building the target object.
            </summary>
            <param name="context">Current build context.</param>
            <returns>Sequence of methods to call.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.ObjectBuilder.SpecifiedPropertiesSelectorPolicy.SelectProperties(Microsoft.Practices.ObjectBuilder2.IBuilderContext)">
            <summary>
            Returns sequence of properties on the given type that
            should be set as part of building that object.
            </summary>
            <param name="context">Current build context.</param>
            <returns>Sequence of <see cref="T:System.Reflection.PropertyInfo"/> objects
            that contain the properties to set.</returns>
        </member>
        <member name="T:Microsoft.Practices.Unity.ResolutionFailedException">
            <summary>
            The exception thrown by the Unity container when
            an attempt to resolve a dependency fails.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.ResolutionFailedException.#ctor(System.Type,System.String,System.Exception)">
            <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.ResolutionFailedException"/> that records
            the exception for the given type and name.
            </summary>
            <param name="typeRequested">Type requested from the container.</param>
            <param name="nameRequested">Name requested from the container.</param>
            <param name="innerException">The actual exception that caused the failure of the build.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.ResolutionFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor to create a <see cref="T:Microsoft.Practices.Unity.ResolutionFailedException"/> from serialized state.
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Serialization context</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.ResolutionFailedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialize this object into the given context.
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="P:Microsoft.Practices.Unity.ResolutionFailedException.TypeRequested">
            <summary>
            The type that was being requested from the container at the time of failure.
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.ResolutionFailedException.NameRequested">
            <summary>
            The name that was being requested from the container at the time of failure.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.ResolvedParameter">
            <summary>
            A class that stores a name and type, and generates a 
            resolver object that resolves the parameter via the
            container.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.ResolvedParameter.#ctor(System.Type)">
            <summary>
            Construct a new <see cref="T:Microsoft.Practices.Unity.ResolvedParameter"/> that
            resolves to the given type.
            </summary>
            <param name="parameterType">Type of this parameter.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.ResolvedParameter.#ctor(System.Type,System.String)">
            <summary>
            Construct a new <see cref="T:Microsoft.Practices.Unity.ResolvedParameter"/> that
            resolves the given type and name.
            </summary>
            <param name="parameterType">Type of this parameter.</param>
            <param name="name">Name to use when resolving parameter.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.ResolvedParameter.GetResolverPolicy">
            <summary>
            Return a <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/> instance that will
            return this types value for the parameter.
            </summary>
            <returns>The <see cref="T:Microsoft.Practices.ObjectBuilder2.IDependencyResolverPolicy"/>.</returns>
        </member>
        <member name="P:Microsoft.Practices.Unity.ResolvedParameter.ParameterType">
            <summary>
            The type of parameter this object represents.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.ResolvedParameter`1">
            <summary>
            A generic version of <see cref="T:Microsoft.Practices.Unity.ResolvedParameter"/> for convenience
            when creating them by hand.
            </summary>
            <typeparam name="TParameter">Type of the parameter</typeparam>
        </member>
        <member name="M:Microsoft.Practices.Unity.ResolvedParameter`1.#ctor">
            <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.ResolvedParameter"/> for the given
            generic type and the default name.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.ResolvedParameter`1.#ctor(System.String)">
            <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.ResolvedParameter"/> for the given
            type and name.
            </summary>
            <param name="name">Name to use to resolve this parameter.</param>
        </member>
        <member name="T:Microsoft.Practices.Unity.UnityContainerBase">
            <summary>
            A base class for implmenting <see cref="T:Microsoft.Practices.Unity.IUnityContainer"/> that provides
            reasonable implementations for most of the overloads defined by the interface.
            The overloads all call down to the non-generic versions of the methods with
            the most parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``2">
            <summary>
            RegisterType a type mapping with the container.
            </summary>
            <remarks>
            <para>
            This method is used to tell the container that when asked for type <typeparamref name="TFrom"/>,
            actually return an instance of type <typeparamref name="TTo"/>. This is very useful for
            getting instances of interfaces.
            </para>
            <para>
            This overload registers a default mapping.
            </para>
            </remarks>
            <typeparam name="TFrom"><see cref="T:System.Type"/> that will be requested.</typeparam>
            <typeparam name="TTo"><see cref="T:System.Type"/> that will actually be returned.</typeparam>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``2(System.String)">
            <summary>
            RegisterType a type mapping with the container.
            </summary>
            <remarks>
            This method is used to tell the container that when asked for type <typeparamref name="TFrom"/>,
            actually return an instance of type <typeparamref name="TTo"/>. This is very useful for
            getting instances of interfaces.
            </remarks>
            <typeparam name="TFrom"><see cref="T:System.Type"/> that will be requested.</typeparam>
            <typeparam name="TTo"><see cref="T:System.Type"/> that will actually be returned.</typeparam>
            <param name="name"></param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``2(Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/>.
            </summary>
            <typeparam name="TFrom"><see cref="T:System.Type"/> that will be requested.</typeparam>
            <typeparam name="TTo"><see cref="T:System.Type"/> that will actually be returned.</typeparam>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``2(System.String,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/>.
            </summary>
            <typeparam name="TFrom"><see cref="T:System.Type"/> that will be requested.</typeparam>
            <typeparam name="TTo"><see cref="T:System.Type"/> that will actually be returned.</typeparam>
            <param name="name">Name to use for registration, null if a default registration.</param>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``1(Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> for the given type with the container.
            No type mapping is performed for this type.
            </summary>
            <typeparam name="T">The type to apply the <paramref name="lifetimeManager"/> to.</typeparam>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType``1(System.String,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
            <typeparam name="T">The type to apply the <paramref name="lifetimeManager"/> to.</typeparam>
            <param name="name">Name that will be used to request the type.</param>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,System.Type)">
            <summary>
            RegisterType a type mapping with the container.
            </summary>
            <remarks>
            <para>
            This method is used to tell the container that when asked for type <paramref name="from"/>,
            actually return an instance of type <paramref name="to"/>. This is very useful for
            getting instances of interfaces.
            </para>
            <para>
            This overload registers a default mapping.
            </para>
            </remarks>
            <param name="from"><see cref="T:System.Type"/> that will be requested.</param>
            <param name="to"><see cref="T:System.Type"/> that will actually be returned.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,System.Type,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/>.
            </summary>
            <param name="from"><see cref="T:System.Type"/> that will be requested.</param>
            <param name="to"><see cref="T:System.Type"/> that will actually be returned.</param>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
            <param name="t">The <see cref="T:System.Type"/> to apply the <paramref name="lifetimeManager"/> to.</param>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> for the given type and name with the container.
            No type mapping is performed for this type.
            </summary>
            <param name="t">The <see cref="T:System.Type"/> to apply the <paramref name="lifetimeManager"/> to.</param>
            <param name="name">Name to use for registration, null if a default registration.</param>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,System.Type,System.String)">
            <summary>
            RegisterType a type mapping with the container.
            </summary>
            <remarks>
            This method is used to tell the container that when asked for type <paramref name="from"/>,
            actually return an instance of type <paramref name="to"/>. This is very useful for
            getting instances of interfaces.
            </remarks>
            <param name="from"><see cref="T:System.Type"/> that will be requested.</param>
            <param name="to"><see cref="T:System.Type"/> that will actually be returned.</param>
            <param name="name">Name to use for registration, null if a default registration.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterType(System.Type,System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/>.
            </summary>
            <param name="from"><see cref="T:System.Type"/> that will be requested.</param>
            <param name="to"><see cref="T:System.Type"/> that will actually be returned.</param>
            <param name="name">Name to use for registration, null if a default registration.</param>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance``1(``0)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            <para>
            This overload does a default registration and has the container take over the lifetime of the instance.</para>
            </remarks>
            <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
            <param name="instance">Object to returned.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance``1(``0,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            <para>
            This overload does a default registration (name = null).
            </para>
            </remarks>
            <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
            <param name="instance">Object to returned.</param>
            <param name="lifetimeManager">
            <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> object that controls how this instance will be managed by the container.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance``1(System.String,``0)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            <para>
            This overload automatically has the container take ownership of the <paramref name="instance"/>.</para>
            </remarks>
            <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
            <param name="instance">Object to returned.</param>
            <param name="name">Name for registration.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance``1(System.String,``0,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            </remarks>
            <typeparam name="TInterface">Type of instance to register (may be an implemented interface instead of the full type).</typeparam>
            <param name="instance">Object to returned.</param>
            <param name="name">Name for registration.</param>
            <param name="lifetimeManager">
            <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> object that controls how this instance will be managed by the container.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance(System.Type,System.Object)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            <para>
            This overload does a default registration and has the container take over the lifetime of the instance.</para>
            </remarks>
            <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
            <param name="instance">Object to returned.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance(System.Type,System.Object,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            <para>
            This overload does a default registration (name = null).
            </para>
            </remarks>
            <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
            <param name="instance">Object to returned.</param>
            <param name="lifetimeManager">
            <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> object that controls how this instance will be managed by the container.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance(System.Type,System.String,System.Object)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            <para>
            This overload automatically has the container take ownership of the <paramref name="instance"/>.</para>
            </remarks>
            <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
            <param name="instance">Object to returned.</param>
            <param name="name">Name for registration.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RegisterInstance(System.Type,System.String,System.Object,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            </remarks>
            <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
            <param name="instance">Object to returned.</param>
            <param name="name">Name for registration.</param>
            <param name="lifetime">
            <para>If true, the container will take over the lifetime of the instance,
            calling Dispose on it (if it's <see cref="T:System.IDisposable"/>) when the container is Disposed.</para>
            <para>
             If false, container will not maintain a strong reference to <paramref name="instance"/>. User is reponsible
            for disposing instance, and for keeping the instance from being garbage collected.</para></param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Resolve``1">
            <summary>
            Get an instance of the default requested type from the container.
            </summary>
            <typeparam name="T"><see cref="T:System.Type"/> of object to get from the container.</typeparam>
            <returns>The retrieved object.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Resolve``1(System.String)">
            <summary>
            Get an instance of the requested type with the given name from the container.
            </summary>
            <typeparam name="T"><see cref="T:System.Type"/> of object to get from the container.</typeparam>
            <param name="name">Name of the object to retrieve.</param>
            <returns>The retrieved object.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Resolve(System.Type)">
            <summary>
            Get an instance of the default requested type from the container.
            </summary>
            <param name="t"><see cref="T:System.Type"/> of object to get from the container.</param>
            <returns>The retrieved object.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Resolve(System.Type,System.String)">
            <summary>
            Get an instance of the requested type with the given name from the container.
            </summary>
            <param name="t"><see cref="T:System.Type"/> of object to get from the container.</param>
            <param name="name">Name of the object to retrieve.</param>
            <returns>The retrieved object.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.ResolveAll``1">
            <summary>
            Return instances of all registered types requested.
            </summary>
            <remarks>
            <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type"/> but different names.
            </para>
            <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
            </remarks>
            <typeparam name="T">The type requested.</typeparam>
            <returns>Set of objects of type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.ResolveAll(System.Type)">
            <summary>
            Return instances of all registered types requested.
            </summary>
            <remarks>
            <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type"/> but different names.
            </para>
            <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
            </remarks>
            <param name="t">The type requested.</param>
            <returns>Set of objects of type <paramref name="t"/>.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.BuildUp``1(``0)">
            <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
            <remarks>
            <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
            <para>
            This overload uses the default registrations.
            </para>
            </remarks>
            <typeparam name="T"><see cref="T:System.Type"/> of object to perform injection on.</typeparam>
            <param name="existing">Instance to build up.</param>
            <returns>The resulting object. By default, this will be <paramref name="existing"/>, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <typeparamref name="T"/>).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.BuildUp``1(``0,System.String)">
            <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
            <remarks>
            <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para></remarks>
            <typeparam name="T"><see cref="T:System.Type"/> of object to perform injection on.</typeparam>
            <param name="existing">Instance to build up.</param>
            <param name="name">name to use when looking up the typemappings and other configurations.</param>
            <returns>The resulting object. By default, this will be <paramref name="existing"/>, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <typeparamref name="T"/>).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.BuildUp(System.Type,System.Object)">
            <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
            <remarks>
            <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para>
            <para>
            This overload uses the default registrations.
            </para>
            </remarks>
            <param name="t"><see cref="T:System.Type"/> of object to perform injection on.</param>
            <param name="existing">Instance to build up.</param>
            <returns>The resulting object. By default, this will be <paramref name="existing"/>, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t"/>).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.BuildUp(System.Type,System.Object,System.String)">
            <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
            <remarks>
            <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para></remarks>
            <param name="t"><see cref="T:System.Type"/> of object to perform injection on.</param>
            <param name="existing">Instance to build up.</param>
            <param name="name">name to use when looking up the typemappings and other configurations.</param>
            <returns>The resulting object. By default, this will be <paramref name="existing"/>, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t"/>).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Teardown(System.Object)">
            <summary>
            Run an existing object through the container, and clean it up.
            </summary>
            <param name="o">The object to tear down.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.AddExtension(Microsoft.Practices.Unity.UnityContainerExtension)">
            <summary>
            Add an extension object to the container.
            </summary>
            <param name="extension"><see cref="T:Microsoft.Practices.Unity.UnityContainerExtension"/> to add.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.AddNewExtension``1">
            <summary>
            Creates a new extension object and adds it to the container.
            </summary>
            <typeparam name="TExtension">Type of <see cref="T:Microsoft.Practices.Unity.UnityContainerExtension"/> to add. The extension type
            must have a zero-argument public constructor.</typeparam>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Configure``1">
            <summary>
            Get access to a configuration interface exposed by an extension.
            </summary>
            <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
            <typeparam name="TConfigurator">The configuration interface required.</typeparam>
            <returns>The requested extension's configuration interface, or null if not found.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Configure(System.Type)">
            <summary>
            Get access to a configuration interface exposed by an extension.
            </summary>
            <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
            <param name="configurationInterface"><see cref="T:System.Type"/> of configuration interface required.</param>
            <returns>The requested extension's configuration interface, or null if not found.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.RemoveAllExtensions">
            <summary>
            Remove all installed extensions from this container.
            </summary>
            <remarks>
            <para>
            This method removes all extensions from the container, including the default ones
            that implement the out-of-the-box behavior. After this method, if you want to use
            the container again you will need to either readd the default extensions or replace
            them with your own.
            </para>
            <para>
            The registered instances and singletons that have already been set up in this container
            do not get removed.
            </para>
            </remarks>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.CreateChildContainer">
            <summary>
            Create a child container.
            </summary>
            <remarks>
            A child container shares the parent's configuration, but can be configured with different
            settings or lifetime.</remarks>
            <returns>The new child container.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainerBase.Dispose">
            <summary>
            Dispose this container instance.
            </summary>
            <remarks>
            Disposing the container also disposes any child containers,
            and disposes any instances whose lifetimes are managed
            by the container.
            </remarks>
        </member>
        <member name="P:Microsoft.Practices.Unity.UnityContainerBase.Parent">
            <summary>
            The parent of this container.
            </summary>
            <value>The parent container, or null if this container doesn't have one.</value>
        </member>
        <member name="T:Microsoft.Practices.Unity.Utility.Guard">
            <summary>
            A static helper class that includes various parameter checking routines.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Guard.ArgumentNotNull(System.Object,System.String)">
            <summary>
            Throws <see cref="T:System.ArgumentNullException"/> if the given argument is null.
            </summary>
            <exception cref="T:System.ArgumentNullException"> if tested value if null.</exception>
            <param name="argumentValue">Argument value to test.</param>
            <param name="argumentName">Name of the argument being tested.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Guard.ArgumentNotNullOrEmpty(System.String,System.String)">
            <summary>
            Throws an exception if the tested string argument is null or the empty string.
            </summary>
            <exception cref="T:System.ArgumentNullException">Thrown if string value is null.</exception>
            <exception cref="T:System.ArgumentException">Thrown if the string is empty</exception>
            <param name="argumentValue">Argument value to check.</param>
            <param name="argumentName">Name of argument being checked.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Guard.TypeIsAssignable(System.Type,System.Type,System.String)">
            <summary>
            Verifies that an argument type is assignable from the provided type (meaning
            interfaces are implemented, or classes exist in the base class hierarchy).
            </summary>
            <param name="assignmentTargetType">The argument type that will be assigned to.</param>
            <param name="assignmentValueType">The type of the value being assigned.</param>
            <param name="argumentName">Argument name.</param>
        </member>
        <member name="T:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage">
            <summary>
            The build stages we use in the Unity container
            strategy pipeline.
            </summary>
        </member>
        <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.Setup">
            <summary>
            First stage. By default, nothing happens here.
            </summary>
        </member>
        <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.TypeMapping">
            <summary>
            Second stage. Type mapping occurs here.
            </summary>
        </member>
        <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.Lifetime">
            <summary>
            Third stage. lifetime managers are checked here,
            and if they're available the rest of the pipeline is skipped.
            </summary>
        </member>
        <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.PreCreation">
            <summary>
            Fourth stage. Reflection over constructors, properties, etc. is
            performed here.
            </summary>
        </member>
        <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.Creation">
            <summary>
            Fifth stage. Instance creation happens here.
            </summary>
        </member>
        <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.Initialization">
            <summary>
            Sixth stage. Property sets and method injection happens here.
            </summary>
        </member>
        <member name="F:Microsoft.Practices.Unity.ObjectBuilder.UnityBuildStage.PostInitialization">
            <summary>
            Seventh and final stage. By default, nothing happens here.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Properties.Resources.ArgumentMustNotBeEmpty">
            <summary>
              Looks up a localized string similar to The provided string argument must not be empty..
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Properties.Resources.CannotInjectIndexer">
            <summary>
              Looks up a localized string similar to The property {0} on type {1} is an indexer. Indexed properties cannot be injected..
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Properties.Resources.CannotInjectStaticMethod">
            <summary>
              Looks up a localized string similar to The method {0}.{1}({2}) is static. Static methods cannot be injected..
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Properties.Resources.LifetimeManagerInUse">
            <summary>
              Looks up a localized string similar to The lifetime manager is already registered. Lifetime managers cannot be reused, please create a new one..
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Properties.Resources.NoSuchConstructor">
            <summary>
              Looks up a localized string similar to The type {0} does not have a constructor that takes the parameters ({1})..
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Properties.Resources.NoSuchMethod">
            <summary>
              Looks up a localized string similar to The type {0} does not have a public method named {1} that takes the parameters ({2})..
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Properties.Resources.NoSuchProperty">
            <summary>
              Looks up a localized string similar to The type {0} does not contain a property named {1}..
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Properties.Resources.PropertyNotSettable">
            <summary>
              Looks up a localized string similar to The property {0} on type {1} is not settable..
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Properties.Resources.PropertyTypeMismatch">
            <summary>
              Looks up a localized string similar to The property {0} on type {1} of type {2}, and cannot be injected with a value of type {3}..
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Properties.Resources.ResolutionFailed">
            <summary>
              Looks up a localized string similar to Resolution of the dependency failed, type = &quot;{0}&quot;, name = &quot;{1}&quot;. See the InnerException for more details..
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Properties.Resources.TypesAreNotAssignable">
            <summary>
              Looks up a localized string similar to The type {1} cannot be assigned to variables of type {0}..
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.UnityContainer">
            <summary>
            A simple, extensible dependency injection container.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.#ctor">
            <summary>
            Create a default <see cref="T:Microsoft.Practices.Unity.UnityContainer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.#ctor(Microsoft.Practices.Unity.UnityContainer)">
            <summary>
            Create a <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> with the given parent container.
            </summary>
            <param name="parent">The parent <see cref="T:Microsoft.Practices.Unity.UnityContainer"/>. The current object
            will apply its own settings first, and then check the parent for additional ones.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.RegisterType(System.Type,System.Type,System.String,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType a type mapping with the container, where the created instances will use
            the given <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/>.
            </summary>
            <param name="from"><see cref="T:System.Type"/> that will be requested.</param>
            <param name="to"><see cref="T:System.Type"/> that will actually be returned.</param>
            <param name="name">Name to use for registration, null if a default registration.</param>
            <param name="lifetimeManager">The <see cref="T:Microsoft.Practices.Unity.LifetimeManager"/> that controls the lifetime
            of the returned instance.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.RegisterInstance(System.Type,System.String,System.Object,Microsoft.Practices.Unity.LifetimeManager)">
            <summary>
            RegisterType an instance with the container.
            </summary>
            <remarks>
            <para>
            Instance registration is much like setting a type as a singleton, except that instead
            of the container creating the instance the first time it is requested, the user
            creates the instance ahead of type and adds that instance to the container.
            </para>
            </remarks>
            <param name="t">Type of instance to register (may be an implemented interface instead of the full type).</param>
            <param name="instance">Object to returned.</param>
            <param name="name">Name for registration.</param>
            <param name="lifetime">
            <para>If true, the container will take over the lifetime of the instance,
            calling Dispose on it (if it's <see cref="T:System.IDisposable"/>) when the container is Disposed.</para>
            <para>
             If false, container will not maintain a strong reference to <paramref name="instance"/>. User is reponsible
            for disposing instance, and for keeping the instance from being garbage collected.</para></param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.Resolve(System.Type,System.String)">
            <summary>
            Get an instance of the requested type with the given name from the container.
            </summary>
            <param name="t"><see cref="T:System.Type"/> of object to get from the container.</param>
            <param name="name">Name of the object to retrieve.</param>
            <returns>The retrieved object.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.ResolveAll(System.Type)">
            <summary>
            Return instances of all registered types requested.
            </summary>
            <remarks>
            <para>
            This method is useful if you've registered multiple types with the same
            <see cref="T:System.Type"/> but different names.
            </para>
            <para>
            Be aware that this method does NOT return an instance for the default (unnamed) registration.
            </para>
            </remarks>
            <param name="t">The type requested.</param>
            <returns>Set of objects of type <paramref name="t"/>.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.BuildUp(System.Type,System.Object,System.String)">
            <summary>
            Run an existing object through the container and perform injection on it.
            </summary>
            <remarks>
            <para>
            This method is useful when you don't control the construction of an
            instance (ASP.NET pages or objects created via XAML, for instance)
            but you still want properties and other injection performed.
            </para></remarks>
            <param name="t"><see cref="T:System.Type"/> of object to perform injection on.</param>
            <param name="existing">Instance to build up.</param>
            <param name="name">name to use when looking up the typemappings and other configurations.</param>
            <returns>The resulting object. By default, this will be <paramref name="existing"/>, but
            container extensions may add things like automatic proxy creation which would
            cause this to return a different object (but still type compatible with <paramref name="t"/>).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.Teardown(System.Object)">
            <summary>
            Run an existing object through the container, and clean it up.
            </summary>
            <param name="o">The object to tear down.</param>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.AddExtension(Microsoft.Practices.Unity.UnityContainerExtension)">
            <summary>
            Add an extension object to the container.
            </summary>
            <param name="extension"><see cref="T:Microsoft.Practices.Unity.UnityContainerExtension"/> to add.</param>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.Configure(System.Type)">
            <summary>
            Get access to a configuration interface exposed by an extension.
            </summary>
            <remarks>Extensions can expose configuration interfaces as well as adding
            strategies and policies to the container. This method walks the list of
            added extensions and returns the first one that implements the requested type.
            </remarks>
            <param name="configurationInterface"><see cref="T:System.Type"/> of configuration interface required.</param>
            <returns>The requested extension's configuration interface, or null if not found.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.RemoveAllExtensions">
            <summary>
            Remove all installed extensions from this container.
            </summary>
            <remarks>
            <para>
            This method removes all extensions from the container, including the default ones
            that implement the out-of-the-box behavior. After this method, if you want to use
            the container again you will need to either readd the default extensions or replace
            them with your own.
            </para>
            <para>
            The registered instances and singletons that have already been set up in this container
            do not get removed.
            </para>
            </remarks>
            <returns>The <see cref="T:Microsoft.Practices.Unity.UnityContainer"/> object that this method was called on (this in C#, Me in Visual Basic).</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.CreateChildContainer">
            <summary>
            Create a child container.
            </summary>
            <remarks>
            A child container shares the parent's configuration, but can be configured with different
            settings or lifetime.</remarks>
            <returns>The new child container.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.Dispose">
            <summary>
            Dispose this container instance.
            </summary>
            <remarks>
            Disposing the container also disposes any child containers,
            and disposes any instances whose lifetimes are managed
            by the container.
            </remarks>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityContainer.Dispose(System.Boolean)">
            <summary>
            Dispose this container instance.
            </summary>
            <remarks>
            This class doesn't have a finalizer, so <paramref name="disposing"/> will always be true.</remarks>
            <param name="disposing">True if being called from the IDisposable.Dispose
            method, false if being called from a finalizer.</param>
        </member>
        <member name="P:Microsoft.Practices.Unity.UnityContainer.Parent">
            <summary>
            The parent of this container.
            </summary>
            <value>The parent container, or null if this container doesn't have one.</value>
        </member>
        <member name="T:Microsoft.Practices.Unity.UnityContainer.ExtensionContextImpl">
            <summary>
            Implementation of the ExtensionContext that is actually used
            by the UnityContainer implementation.
            </summary>
            <remarks>
            This is a nested class so that it can access state in the
            container that would otherwise be inaccessible.
            </remarks>
        </member>
        <member name="E:Microsoft.Practices.Unity.UnityContainer.ExtensionContextImpl.RegisteringInstance">
            <summary>
            This event is raised when the <see cref="M:Microsoft.Practices.Unity.UnityContainer.RegisterInstance(System.Type,System.String,System.Object,Microsoft.Practices.Unity.LifetimeManager)"/> method,
            or one of its overloads, is called.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.UnityDefaultBehaviorExtension">
            <summary>
            This extension supplies the default behavior of the UnityContainer API
            by handling the context events and setting policies.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityDefaultBehaviorExtension.Initialize">
            <summary>
            Install the default container behavior into the container.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityDefaultBehaviorExtension.Remove">
            <summary>
            Remove the default behavior from the container.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.UnityDefaultStrategiesExtension">
            <summary>
            This extension installs the default strategies and policies into the container
            to implement the standard behavior of the Unity container.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.UnityDefaultStrategiesExtension.Initialize">
            <summary>
            Add the default ObjectBuilder strategies &amp; policies to the container.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.Utility.Pair`2">
            <summary>
            A helper class that encapsulates two different
            data items together into a a single item.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Pair`2.#ctor(`0,`1)">
            <summary>
            Create a new <see cref="T:Microsoft.Practices.Unity.Utility.Pair`2"/> containing
            the two values give.
            </summary>
            <param name="first">First value</param>
            <param name="second">Second value</param>
        </member>
        <member name="P:Microsoft.Practices.Unity.Utility.Pair`2.First">
            <summary>
            The first value of the pair.
            </summary>
        </member>
        <member name="P:Microsoft.Practices.Unity.Utility.Pair`2.Second">
            <summary>
            The second value of the pair.
            </summary>
        </member>
        <member name="T:Microsoft.Practices.Unity.Utility.Pair">
            <summary>
            Container for a Pair helper method.
            </summary>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Pair.Make``2(``0,``1)">
            <summary>
            A helper factory method that lets users take advantage of type inference.
            </summary>
            <typeparam name="TFirstParam">Type of first value.</typeparam>
            <typeparam name="TSecondParam">Type of second value.</typeparam>
            <param name="first">First value.</param>
            <param name="second">Second value.</param>
            <returns>A new <see cref="T:Microsoft.Practices.Unity.Utility.Pair`2"/> instance.</returns>
        </member>
        <member name="T:Microsoft.Practices.Unity.Utility.Sequence">
            <summary>
            A series of helper methods to deal with sequences -
            objects that implement <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <remarks>LINQ in C# 3.0 does pretty much the same stuff,
            but we're keeping C# 2.0 compatibility here.</remarks>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Sequence.ToList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Given an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, return a
            new <see cref="T:System.Collections.Generic.List`1"/> containing the same contents.
            </summary>
            <typeparam name="T">Type of item store in the sequence.</typeparam>
            <param name="seq">Sequence to create list from.</param>
            <returns>The new <see cref="T:System.Collections.Generic.List`1"/></returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Sequence.OfType``1(System.Collections.IEnumerable)">
            <summary>
            Given an <see cref="T:System.Collections.IEnumerable"/> return a new
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains
            all the objects in <paramref name="source"/> that
            are castable to <typeparamref name="TResult"/>.
            </summary>
            <typeparam name="TResult">Desired type for objects.</typeparam>
            <param name="source">Input sequence.</param>
            <returns>New output sequence.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Sequence.Collect``1(``0[])">
            <summary>
            A function that turns an arbitrary parameter list into an
            <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">Type of arguments.</typeparam>
            <param name="arguments">The items to put into the collection.</param>
            <returns>An array that contains the values of the <paramref name="arguments"/>.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Sequence.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Create an array containing the elements of the given sequence.
            </summary>
            <typeparam name="T">Type of sequence and array.</typeparam>
            <param name="sequence">Input sequence.</param>
            <returns>The resulting array.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Sequence.Map``2(System.Collections.Generic.IEnumerable{``0},System.Converter{``0,``1})">
            <summary>
            Given a sequence of <typeparamref name="TIn"/>, returns a sequence of
            <typeparamref name="TOut"/> created by running the items in <paramref name="input"/>
            through <paramref name="converter"/>.
            </summary>
            <typeparam name="TIn">Type of items in input.</typeparam>
            <typeparam name="TOut">Type of items in output.</typeparam>
            <param name="input">Input sequence.</param>
            <param name="converter">Mapping function.</param>
            <returns>The converted output sequence.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Sequence.Reduce``2(System.Collections.Generic.IEnumerable{``0},``1,Microsoft.Practices.Unity.Utility.Sequence.Reducer{``0,``1})">
            <summary>
            Run a functional Reduce operation. See other methods for examples.
            </summary>
            <typeparam name="TSource">Type of inputs.</typeparam>
            <typeparam name="TDest">Type of final output.</typeparam>
            <param name="sequence">Sequence of input items.</param>
            <param name="initialValue">Initial value for accumulator.</param>
            <param name="reducer">Reduce function.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Sequence.ToString``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Converter{``0,System.String})">
            <summary>
            Convert the given sequence to a single string. The items in the string are
            separated by the given separator, and each object is converted to a string
            using the <paramref name="converter"/> method given.
            </summary>
            <typeparam name="T">Type of input sequence.</typeparam>
            <param name="sequence">Input sequence.</param>
            <param name="separator">Separator string.</param>
            <param name="converter">Function to convert <typeparamref name="T"/> instances to
            strings.</param>
            <returns>The collected string.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Sequence.ToString``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Convert the given sequence to a single string. The items in the string are separated
            by the given separator, and each object is converted to a string by calling its
            <see cref="M:System.Object.ToString"/>  method.
            </summary>
            <typeparam name="T">Type of input sequence.</typeparam>
            <param name="sequence">Input sequence.</param>
            <param name="separator">Separator string.</param>
            <returns>The collected string.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Sequence.First``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Return the first item in the given sequence.
            </summary>
            <exception cref="T:System.InvalidOperationException">Thrown if the sequence is empty.</exception>
            <typeparam name="T">Type of items in the sequence.</typeparam>
            <param name="sequence">The sequence.</param>
            <returns>First item in the sequence.</returns>
        </member>
        <member name="M:Microsoft.Practices.Unity.Utility.Sequence.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Execute the given action delegate for each item in the sequence.
            </summary>
            <typeparam name="TItem">Type of item in the sequence.</typeparam>
            <param name="sequence">The sequence of items.</param>
            <param name="action">Action to perform on each item.</param>
        </member>
        <member name="T:Microsoft.Practices.Unity.Utility.Sequence.Reducer`2">
            <summary>
            A delegate that defines the function passed to the <see cref="M:Microsoft.Practices.Unity.Utility.Sequence.Reduce``2(System.Collections.Generic.IEnumerable{``0},``1,Microsoft.Practices.Unity.Utility.Sequence.Reducer{``0,``1})"/> methods.
            </summary>
            <typeparam name="TSource">Type of item being reduced.</typeparam>
            <typeparam name="TDest">Type of the accumulator object.</typeparam>
            <param name="currentItem">Current item to process.</param>
            <param name="accumulator">Current value of the accumulator.</param>
            <returns></returns>
        </member>
    </members>
</doc>
